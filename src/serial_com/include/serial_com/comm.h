// Generated by gencpp from file serial_com/comm.msg
// DO NOT EDIT!


#ifndef SERIAL_COM_MESSAGE_COMM_H
#define SERIAL_COM_MESSAGE_COMM_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace serial_com
{
template <class ContainerAllocator>
struct comm_
{
  typedef comm_<ContainerAllocator> Type;

  comm_()
    : x1(0.0)
    , y1(0.0)
    , x2(0.0)
    , y2(0.0)
    , x3(0.0)
    , y3(0.0)
    , x4(0.0)
    , y4(0.0)
    , x5(0.0)
    , y5(0.0)
    , x6(0.0)
    , y6(0.0)
    , x7(0.0)
    , y7(0.0)
    , x8(0.0)
    , y8(0.0)
    , color(0)  {
    }
  comm_(const ContainerAllocator& _alloc)
    : x1(0.0)
    , y1(0.0)
    , x2(0.0)
    , y2(0.0)
    , x3(0.0)
    , y3(0.0)
    , x4(0.0)
    , y4(0.0)
    , x5(0.0)
    , y5(0.0)
    , x6(0.0)
    , y6(0.0)
    , x7(0.0)
    , y7(0.0)
    , x8(0.0)
    , y8(0.0)
    , color(0)  {
  (void)_alloc;
    }



   typedef float _x1_type;
  _x1_type x1;

   typedef float _y1_type;
  _y1_type y1;

   typedef float _x2_type;
  _x2_type x2;

   typedef float _y2_type;
  _y2_type y2;

   typedef float _x3_type;
  _x3_type x3;

   typedef float _y3_type;
  _y3_type y3;

   typedef float _x4_type;
  _x4_type x4;

   typedef float _y4_type;
  _y4_type y4;

   typedef float _x5_type;
  _x5_type x5;

   typedef float _y5_type;
  _y5_type y5;

   typedef float _x6_type;
  _x6_type x6;

   typedef float _y6_type;
  _y6_type y6;

   typedef float _x7_type;
  _x7_type x7;

   typedef float _y7_type;
  _y7_type y7;

   typedef float _x8_type;
  _x8_type x8;

   typedef float _y8_type;
  _y8_type y8;

   typedef uint8_t _color_type;
  _color_type color;





  typedef boost::shared_ptr< ::serial_com::comm_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::serial_com::comm_<ContainerAllocator> const> ConstPtr;

}; // struct comm_

typedef ::serial_com::comm_<std::allocator<void> > comm;

typedef boost::shared_ptr< ::serial_com::comm > commPtr;
typedef boost::shared_ptr< ::serial_com::comm const> commConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::serial_com::comm_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::serial_com::comm_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::serial_com::comm_<ContainerAllocator1> & lhs, const ::serial_com::comm_<ContainerAllocator2> & rhs)
{
  return lhs.x1 == rhs.x1 &&
    lhs.y1 == rhs.y1 &&
    lhs.x2 == rhs.x2 &&
    lhs.y2 == rhs.y2 &&
    lhs.x3 == rhs.x3 &&
    lhs.y3 == rhs.y3 &&
    lhs.x4 == rhs.x4 &&
    lhs.y4 == rhs.y4 &&
    lhs.x5 == rhs.x5 &&
    lhs.y5 == rhs.y5 &&
    lhs.x6 == rhs.x6 &&
    lhs.y6 == rhs.y6 &&
    lhs.x7 == rhs.x7 &&
    lhs.y7 == rhs.y7 &&
    lhs.x8 == rhs.x8 &&
    lhs.y8 == rhs.y8 &&
    lhs.color == rhs.color;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::serial_com::comm_<ContainerAllocator1> & lhs, const ::serial_com::comm_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace serial_com

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::serial_com::comm_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::serial_com::comm_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::serial_com::comm_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::serial_com::comm_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::serial_com::comm_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::serial_com::comm_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::serial_com::comm_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a26abbe9956bba5808d6b46edd73a870";
  }

  static const char* value(const ::serial_com::comm_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xa26abbe9956bba58ULL;
  static const uint64_t static_value2 = 0x08d6b46edd73a870ULL;
};

template<class ContainerAllocator>
struct DataType< ::serial_com::comm_<ContainerAllocator> >
{
  static const char* value()
  {
    return "serial_com/comm";
  }

  static const char* value(const ::serial_com::comm_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::serial_com::comm_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 x1\n"
"float32 y1\n"
"float32 x2\n"
"float32 y2\n"
"float32 x3\n"
"float32 y3\n"
"float32 x4\n"
"float32 y4\n"
"float32 x5\n"
"float32 y5\n"
"float32 x6\n"
"float32 y6\n"
"float32 x7\n"
"float32 y7\n"
"float32 x8\n"
"float32 y8\n"
"uint8 color\n"
;
  }

  static const char* value(const ::serial_com::comm_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::serial_com::comm_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.x1);
      stream.next(m.y1);
      stream.next(m.x2);
      stream.next(m.y2);
      stream.next(m.x3);
      stream.next(m.y3);
      stream.next(m.x4);
      stream.next(m.y4);
      stream.next(m.x5);
      stream.next(m.y5);
      stream.next(m.x6);
      stream.next(m.y6);
      stream.next(m.x7);
      stream.next(m.y7);
      stream.next(m.x8);
      stream.next(m.y8);
      stream.next(m.color);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct comm_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::serial_com::comm_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::serial_com::comm_<ContainerAllocator>& v)
  {
    s << indent << "x1: ";
    Printer<float>::stream(s, indent + "  ", v.x1);
    s << indent << "y1: ";
    Printer<float>::stream(s, indent + "  ", v.y1);
    s << indent << "x2: ";
    Printer<float>::stream(s, indent + "  ", v.x2);
    s << indent << "y2: ";
    Printer<float>::stream(s, indent + "  ", v.y2);
    s << indent << "x3: ";
    Printer<float>::stream(s, indent + "  ", v.x3);
    s << indent << "y3: ";
    Printer<float>::stream(s, indent + "  ", v.y3);
    s << indent << "x4: ";
    Printer<float>::stream(s, indent + "  ", v.x4);
    s << indent << "y4: ";
    Printer<float>::stream(s, indent + "  ", v.y4);
    s << indent << "x5: ";
    Printer<float>::stream(s, indent + "  ", v.x5);
    s << indent << "y5: ";
    Printer<float>::stream(s, indent + "  ", v.y5);
    s << indent << "x6: ";
    Printer<float>::stream(s, indent + "  ", v.x6);
    s << indent << "y6: ";
    Printer<float>::stream(s, indent + "  ", v.y6);
    s << indent << "x7: ";
    Printer<float>::stream(s, indent + "  ", v.x7);
    s << indent << "y7: ";
    Printer<float>::stream(s, indent + "  ", v.y7);
    s << indent << "x8: ";
    Printer<float>::stream(s, indent + "  ", v.x8);
    s << indent << "y8: ";
    Printer<float>::stream(s, indent + "  ", v.y8);
    s << indent << "color: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.color);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SERIAL_COM_MESSAGE_COMM_H
